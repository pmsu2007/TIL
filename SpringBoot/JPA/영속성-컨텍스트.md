# 영속성 컨텍스트 (Persistence Context)

### 영속성 컨텍스트란

영속성 컨텍스트는 **엔티티를 영구 저장하는 환경** 이다.

영속성 컨텍스트는 엔티티 매니저를 생성할 때 만들어지며, 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있다. 

### 엔티티의 생명주기

- 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태

- 영속 (managed) : 영속성 컨텍스트에 저장된 상태

- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태

- 삭제 (removed) : 삭제된 상태

#### 비영속

순수한 객체 상태의 엔티티이며, 영속성 컨텍스트나 데이터베이스와 전혀 관련이 없는 상태이다.

```java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

#### 영속

영속 상태는 **영속성 컨텍스트에 의해 관리되는 엔티티**이다.

```java
// 객체를 영속성 컨텍스트에 저장한 상태
em.persist(member);
```
엔티티 매니저를 통해서 `em.persist()`로 영속성 컨텍스트에 저장한 엔티티와

`em.find()`나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태이다.

#### 준영속

영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.

특정 엔티티를 준영속 상태로 만들기 위해서는

1. `em.detach()`를 호출하거나

2. `em.close()`를 호출하여 영속성 컨텍스트를 닫거나

3. `em.clear()`를 호출해서 영속성 컨텍스트를 초기화거나

위의 방법을 적용하면 된다.

#### 삭제

`em.remove()`를 호출하여 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제하는 것. 

### 영속성 컨텍스트의 특징

#### 영속성 컨텍스트와 식별자 값

영속성 컨텍스트는 <u>**엔티티를 식별자 값으로 구분**</u>한다. 

따라서, 영속 상태는 식별자 값이 반드시 있어야 하며, 식별자 값이 없다면 예외가 발생한다.

> 식별자는 **@Id로 테이블의 기본 키와 매핑한 값**이다.

#### 1차 캐시

1차 캐시는 영속성 컨텍스트 내부에 있는 캐시이다.

영속 상태의 엔티티는 모두 이곳에 저장되며, **키(Key)는 @Id로 매핑한 식별자이고 값(Value)은 엔티티 인스턴스를 담는 Map 자료구조**라고 생각하면 된다.

`em.find()`를 호출하여 엔티티를 찾을 때, **가장 먼저 1차 캐시에서 엔티티를 찾고** 만약 없다면 데이터베이스에서 조회해온다.

데이터베이스에서 조회했을 경우, 엔티티를 생성하고 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환한다.

#### 영속 엔티티의 동일성 보장

```java
em.find(Member.class, "member1")
```
위와 같이 엔티티를 조회하는 코드를 반복해서 호출하더라도 **영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환**한다.

따라서, 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.


> 동일성 (identity) : 실제 인스턴스가 같다. `==` 비교의 값이 같다

> 동등성 (equality) : 실제 인스턴스는 다를 수 있지만, 인스턴스가 가지고 있는 값이 같다.

#### 쓰기 지연

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

// 데이터 변경 시 트랜잭션을 시작해야한다.
transaction.begin();

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit();
```
엔티티 매니저는 **트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 모아두고, 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데** 이를 트랙잭션을 지원하는 쓰기 지연이라고 한다.

영속성 컨텍스트는 1차 캐시에 엔티티를 저장하면서 **동시에 해당 엔티티 정보로 SQL 쿼리를 만들고 해당 쿼리를 쓰기 지연 SQL 저장소에 보관**한다.

트랜잭션을 커밋하면 엔티티 매니저는 가장 먼저 영속성 컨텍스트를 플러시한다.

플러시는 **영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화**하는 작업인데 이 때 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다.

#### 변경 감지 (Dirty Checking)

JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경해주면 된다.

변경 감지(dirty checking)은 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능이다.

JPA는 엔티티를 영속성 컨텍스트에 보관할 때 **최초 상태를 복사한 스냅샷을 저장해 두는데, 플러시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다.**

이 때, 변경된 엔티티가 있다면 수정 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보낸다.

여기서 주의햘 졈은 **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용**된다.

<br/>

JPA의 변경 감지로 인해 실행된 UPDATE SQL은 **엔티티의 모든 필드를 업데이트**한다.

모든 필드를 사용하면 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있으나, 

1. 모든 필드를 사용하게 되면 수정 쿼리가 항상 같아진다. 따라서, 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다.

2. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.

와 같은 장점이 있기 때문에 엔티티의 모든 필드를 업데이트 한다.

<br/>

필드가 많거나 저장되는 내용이 크다면 `org.hibernate.annotations.DynamicUpdate` 어노테이션을 사용하여 수정된 데이터만 사용하여 동적으로 UPDATE SQL을 생성할 수 있다.

컬림의 수가 대략 30개 이상이 되면 기존 방식보다 `@DynamicUpdate`를 사용하는 것이 빠르다고 하나, 한 테이블에 컬럼이 30개 이상 된다는 것은 테이블 설계가 잘못되어있을 가능성이 높다.

#### 엔티티 삭제

엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.

```java
Member memberA = em.find(Member.class, "memberA"); // 삭제 대상 엔티티 조회
em.remove(memberA);
```
`em.remove()`를 호출한다고 해서 엔티티를 즉시 삭제하는 것이 아니라 삭제 쿼리를 쓰기 지연 SQL 저장소에 저장하고, 이후 트랜잭션을 커밋해서 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를 전달한다.

### 플러시 (Flush)

플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

플러시를 실행하면 다음 과정을 거치게 된다.

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 수정된 엔티티를 찾는다. (수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록된다.)
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

#### 영속성 컨텍스트를 플러시하는 방법 3가지

1. **직접 호출 : `em.flush()`**
   
   엔티티 매니저의 `flush()`를 직접 호출해서 영속성 컨텍스트를 강제로 플러시한다. <br/>
   테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용하지 않는다.

2. **트랜잭션 커밋 시 플러시 자동 호출**
   
   데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스 반영되지 않는다. <br/>
   따라서, 트랜잭션을 커밋하기 전에 꼭 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영해야 한다.

3. **JPQL 쿼리 실행 시 플러시 자동 호출**

    ```java
    em.persist(memberA);
    em.persist(memberB);
    em.persist(memberC);

    // 중간에 JPQL 실행
    query = em.createQuery("select m from Member m", Member.class);
    List<Member> members = query.getResultList();
    ```

    위와 같이 `em.persist()`를 호출하여 엔티티를 영속 상태로 만들더라도 데이터베이스에는 반영되지 않는다. 

    이 상태에서 JPQL을 실행하면 SQL로 변환되어 데이터베이스에서 데이터를 조회하지만, 데이터가 없어 쿼리 결과로 조회되지 않는다.

    따라서, JPA는 JPQL을 실행할 때 플러시를 자동 호출하여 변경 내용을 데이터베이스에 반영한다.

    식별자를 기준으로 조회하는 `find()` 메소드를 호출할 때는 플러시가 실행되지 않는다.

#### 플러시 모드 옵션

엔티티 매니저에 **플러시 모드를 직접 지정**하려면 `javax.persistence.FlushModeType`을 사용하면 된다.

- `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할 때 플러시 (기본 값)

- `FlushModeType.COMMIT` : 커밋할 때만 플러시

> `COMMIT` 모드는 성능 최적화를 위해 사용한다.

플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이지, 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안된다.

### 준영속

준영속은 **영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것**을 말한다.

따라서, 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

1. 특정 엔티티만 준영속으로 전환 : `em.detach(entity)`

2. 영속성 컨텍스트를 완전히 초기화한다. : `em.clear()`

3. 영속성 컨텍스트를 종료한다. : `em.close()`

영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다.

#### 준영속 상태의 특징

- **거의 비영속 상태에 가깝다**
  
  영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.

- **식별자 값을 가지고 있다.**
  
  비영속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.

- **지연 로딩을 할 수 없다.**
  
  지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.

  하지만 더 이상 영속성 컨텍스트가 관리하지 않으므로 지연 로딩 시 문제가 발생한다.

#### 병합: merge()

준영속 상태의 엔티티를 다시 영속 상태로 변경할 때 사용한다.

`merge()`는 **준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환**한다.

또한, 비영속 상태의 엔티티도 영속 상태로 만들 수 있다.