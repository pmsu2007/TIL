# 비트마스크 (BitMask)

비트 마스크는 이진수를 활용하는 컴퓨터의 연산 방식을 이용하여, **정수의 이진수 표현을 자료 구조를 쓰는 기법**을 말한다.

### 비트 마스크의 장점

1. **수행 시간이 빠르다**
   
   비트 마스크는 비트(bit) 연산을 하므로 O(1)에 처리되는 경우가 많기 때문에 비트의 개수만큼 요소를 다룰 수 있기 때문에 연산의 횟수가 많아질수록 유리하다.

2. **코드가 짧고 간결하다**
   
   다양한 집합 연산들을 비트 연산자로 작성할 수 있기 때문에, 반복문/조건문 등을 이용한 코드보다 훨씬 간결한 코드를 작성할 수 있다.

3. **메모리 사용량이 더 적다**
   
   만약, 비트(bit)가 10개인 경우에는 각 bit당 2가지 경우의 수를 가지기 때문에 2^10 가지의 경우를 10bit 이진수 하나로 표현할 수 있다.

   즉, 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이다. -> DP에 매우 효율적으로 동작함.

### 비트 마스크를 이용한 집합

비트 마스크를 이용한 집합에서는 하나의 비트(bit)가 하나의 원소를 의미한다.

비트(bit)가 1 이라면 해당 원소가 집합에 포함되어 있다는 의미이고, 0 이라면 집합에 포함되어 있지 않다는 의미이다.

따라서, **N비트 정수 변수라면 N개의 원소를 갖는 집합의 부분집합을 모두 표현**할 수 있다.

- 공집합 만들기
  0은 모든 비트가 비어있음을 나타내므로 공집합을 만들 수 있다.
  ```java
  A = 0;
  ```  

- 꽉찬 집합 만들기 (집합의 원소가 10이라 가정)
  
  1 < 10 은 10000000000 (2) 이므로 여기서 1을 빼주면 1111111111(2)가 되어 꽉찬 집합을 만들 수 있다.
  ```
  A = (1 << 10) - 1;
  ```

- 집합에 원소 K 추가
  
  K 번째 비트를 1로 갖는 수를 만들고 OR 연산으로 처리한다.
  ```java
  A |= (1 << K);
  ```  

- 집합에 원소 K 삭제
  
  K 번째 비트를 0으로 갖는 수를 만들고 AND 연산으로 처리한다.
  ```java
  A &= ~(1 << K);
  ```  

- 집합에 원소 K가 포함되어 있는지 확인 
  
  K 번째 비트가 1인지 확인해주면 된다.
  ```java
  if (A & (1 << K))
  ```  

- 집합에 원소 K 뒤집기
  
  XOR 연산으로 처리해준다.
  ```java
  A ^= (1 << K);
  ```  

- 집합의 크기 구하기
  
  1의 값을 갖는 비트를 세어주면 된다.
  ```java
  int count(int A) {
    if (A == 0) return 0;
    
    return A % 2 + count(A / 2);
  }

  Integer.bitCount(A);
  ```  

- 집합에 최소 원소 찾기
  
  값이 1인 비트 중 가장 오른쪽에 있는 비트를 찾으면 된다.



## 출처

- https://rebro.kr/63#recentComments