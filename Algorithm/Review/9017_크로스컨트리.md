# BOJ 9017\_크로스컨트리

## 사고 흐름

가장 먼저 입력의 크기와 시간 제한을 확인하였다.

### 입력

- 테스트 케이스 T (크기 조건 없음)
- 각 선수의 팀 번호 정보 N (6 <= N <= 1,000)
- 팀 번호 M (1 <= M <= 200)

시간 제한이 1초이기 때문에 O(N^2) 까지는 괜찮다고 생각하였다.

처음 문제를 풀 때 다음과 같이 생각하고 풀었다.

**참가 선수가 6명인 팀**의 **모든 주자의 점수를 계산**하고 **동점자가 있다면 5번째 주자를 비교** 하여 우승팀 구하기

여기서 모든 주자의 점수를 계산하는 것이 아닌 **상위 4명의 주자만 계산**한다는 점과 **6명이 채워지지 않은 팀은 점수 계산에서 제외**된 다는 점을 놓쳤다.

### 시간 복잡도

테스트 케이스를 제외하고,

1. 각 팀의 팀원 수 구하기 : O(N)
2. 팀원의 수가 6명 이상인 팀의 선수별 점수 매기기 : O(N)
3. 팀원의 수가 6명 이상인 팀의 최종 점수 계산하기 : O(M)
4. 최종 점수 중 최소 점수 구하기 : O(M)
5. 우승자 구하기 : O(M)

## 복기

### 최적화

동점자가 발생할 경우, 우승 팀을 결정하기 위해 5 번째 선수의 점수가 필요하기 때문에 모든 선수의 점수를 저장할 수 있도록 2차원 배열을 선언하였는데 <u>각 팀의 5번째 선수의 점수만 따로 저장할 수 있게 일차원 배열을 선언하는 것이 더 효율적인 코드</u>이다.

5번째 선수의 점수만 따로 저장하는 일차원 배열을 사용함으로써 얻을 수 있는 이점은 다음과 같다.

1. 불필요한 메모리를 줄일 수 있다.
2. 우승자를 구하는 과정에서 다음과 같이 코드를 간결하게 작성할 수 있다.

```java
int winner = 0;
int winnerScore = Integer.MAX_VALUE;
    for(int i = 1;i <= 200; i++) {
        if(teams[i] == 6) {
            if (scores[i] < winnerScore) {
                winnerScore = scores[i];
				winner = i;
            } else if (scores[i] == winnerScore) {
                if(five[i] < five[ans]) winner = i;
            }
        }
    }
```
